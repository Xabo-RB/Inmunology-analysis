function ODE(dx, x, p, t) # CARRGO model
    dx[1] = p[4] * x[1] * (1 - x[1] / p[5]) - p[1] * x[1] * x[2]
    dx[2] = p[2]* x[1] * x[2] - p[3] * x[2]
end

# p[1] = KON
# P[2] = KOFF
# P[3] = KP

function ODEOccupancy(dx, x, p, t) # Occuppancy model
    dx[1] = p[1]*x[2]*x[3] - p[2]*x[1]                      #C0
    dx[2] = - p[1] * x[2] * x[3] + p[2]*x[1]                # P
    dx[3] = - p[1] * x[3] * x[3] + p[2]*x[1]                # T

end

function ODEKPRmcK(dx, x, p, t) # McKeithan
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4]
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3]
    dx[4] = p[3]*x[3] - p[2]*x[4] #C1 = R

    #   p = complex([5e-5, 0.01, 0.01]);
    #   kon = 5e-5 // koff = 0.01 // kp = 0.01
    #   x0 = complex([100, 2e4, 0, 0]);
    #   P = 100 // T = 20.000 // C0 = 0 // C1 = 0
end

# con esta s√≠ que obtengo el resultado del Paper
function ODEKPRmcK10(dx, x, p, t) # McKeithan
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[2]*x[8] + p[2]*x[9] + p[2]*x[10] + p[2]*x[11] + p[2]*x[12] + p[2]*x[13] # P
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[2]*x[8] + p[2]*x[9] + p[2]*x[10] + p[2]*x[11] + p[2]*x[12] + p[2]*x[13] # T
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3] # C0
    dx[4] = p[3]*x[3] - (p[2] + p[3])*x[4] # C1
    dx[5] = p[3]*x[4] - (p[2] + p[3])*x[5] # C2
    dx[6] = p[3]*x[5] - (p[2] + p[3])*x[6] # C3
    dx[7] = p[3]*x[6] - (p[2] + p[3])*x[7] # C4
    dx[8] = p[3]*x[7] - (p[2] + p[3])*x[8] # C5
    dx[9] = p[3]*x[8] - (p[2] + p[3])*x[9] # C6
    dx[10] = p[3]*x[9] - (p[2] + p[3])*x[10] # C7
    dx[11] = p[3]*x[10] - (p[2] + p[3])*x[11] # C8
    dx[12] = p[3]*x[11] - (p[2] + p[3])*x[12] # C9
    dx[13] = p[3]*x[12] - p[2]*x[13] # C10
    #dx[13] = p[3]*x[12] # C10

end

function ODEKPRLimSig(dx, x, p, t) #Limited Signaliing
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[2]*x[8] + p[2]*x[9]
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[2]*x[8] + p[2]*x[9]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3]
    dx[4] = p[3]*x[3] - (p[2] + p[3])*x[4]
    dx[5] = p[3]*x[4] - (p[2] + p[3])*x[5]
    dx[6] = p[3]*x[5] - (p[2] + p[3])*x[6]
    dx[7] = p[3]*x[6] - (p[2] + p[3])*x[7]
    dx[8] = p[3]*x[7] - (p[2] + p[4])*x[8]
    dx[9] = p[4]*x[8] - p[2]*x[9]
end

function ODEKPRSustSig(dx, x, p, t) #Sustained Signaliing
    # lambda = p[4]
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[2]*x[8] - p[1] * x[1] * x[9]
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[4] * x[9]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3]
    dx[4] = p[3]*x[3] - (p[2] + p[3])*x[4]
    dx[5] = p[3]*x[4] - (p[2] + p[3])*x[5]
    dx[6] = p[3]*x[5] - (p[2] + p[3])*x[6]
    dx[7] = p[3]*x[6] - (p[2] + p[3])*x[7]
    dx[8] = p[3]*x[7] - p[2]*x[8] + p[1]*x[1]*x[9]
    dx[9] = p[2]*x[8] - p[1]*x[1]*x[9] - p[4]*x[9]
end

function ODEKPRNegFeed(dx, x, p, t) #Negative feedback
    # gamma = p[4]
    # b = p[5]
    # beta = p[6]
    # alpha = p[7]
    # ST = p[8]
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[2]*x[8]
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5] + p[2]*x[6] + p[2]*x[7] + p[2]*x[8]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3] + (p[5] + p[4]*x[9])*x[4]
    dx[4] = p[3]*x[3] - (p[2] + p[3] + p[5] + p[4]*x[9])*x[4] + (p[5] + p[4]*x[9])*x[5]
    dx[5] = p[3]*x[4] - (p[2] + p[3] + p[5] + p[4]*x[9])*x[5] + (p[5] + p[4]*x[9])*x[6]
    dx[6] = p[3]*x[5] - (p[2] + p[3] + p[5] + p[4]*x[9])*x[6] + (p[5] + p[4]*x[9])*x[7]
    dx[7] = p[3]*x[6] - (p[2] + p[3] + p[5] + p[4]*x[9])*x[7] + (p[5] + p[4]*x[9])*x[8]
    dx[8] = p[3]*x[7] - (p[2] + p[5] + p[4]*x[9])*x[8]
    dx[9] = p[7]*x[4]*(p[8] - x[9]) - p[6]*x[9]

end

function ODEBachmann(dx, x, p, t) # Bachmann
    # x[1] = T(t), p[3] = keff, 
    dx[1] = - p[3] * (x[1]^2)*((p[1]/p[2])^2)
end

function ODEStabChain(dx, x, p, t) # Galvez
    # r_p = p[5], r = p[4]
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + (2/(1+p[4]))*p[2]*x[4] + (3/(1+2*p[4]))*p[2]*x[5] + (4/(1 + 3*p[4]))*p[2]*x[6] + ((5/(1 + 4*p[4]))*p[2])*x[7] + (6/(1 + 5*p[4]))*p[2]*x[8]
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + (2/(1+p[4]))*p[2]*x[4] + (3/(1+2*p[4]))*p[2]*x[5] + (4/(1 + 3*p[4]))*p[2]*x[6] + ((5/(1 + 4*p[4]))*p[2])*x[7] + (6/(1 + 5*p[4]))*p[2]*x[8]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3]
    dx[4] = p[3]*x[3] - ((2/(1+p[4]))*p[2] + p[5]*p[3])*x[4]
    dx[5] = p[5]*p[3]*x[5] - ((3/(1 + 2*p[4]))*p[2] + (p[5]^2)*p[3])*x[5]
    dx[6] = (p[5]^2)*p[3]*x[5] - ((4/(1 + 3*p[4]))*p[2] + (p[5]^3)*p[3])*x[6]
    dx[7] = (p[5]^3)*p[3]*x[6] - ((5/(1 + 4*p[4]))*p[2] + (p[5]^4)*p[3])*x[7]
    dx[8] = (p[5]^4)*p[3]*x[7] - (6/(1 + 5*p[4]))*p[2]*x[8]

end

function ODEStabChain2(dx, x, p, t) # Galvez
    # r_p = p[5], r = p[4]
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + (2/(1+p[4]))*p[2]*x[4] + (3/(1+2*p[4]))*p[2]*x[5]
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + (2/(1+p[4]))*p[2]*x[4] + (3/(1+2*p[4]))*p[2]*x[5]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3]
    dx[4] = p[3]*x[3] - ((2/(1+p[4]))*p[2] + p[5]*p[3])*x[4]
    dx[5] = p[5]*p[3]*x[4] - (3/(1 + 2*p[4]))*p[2]*x[5]
end

function ODELimIFF(dx, x, p, t) # Limited signaling IFF
    # phi = p[4],   gamma = p[5],   lambda = p[6],  delta = p[7],   YT = p[8],  PT = p[9],  mu = p[10], gamma_menos = p[11]
    dx[1] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5]
    dx[2] = - p[1] * x[1] * x[2] + p[2]*x[3] + p[2]*x[4] + p[2]*x[5]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3]
    dx[4] = p[3]*x[3] - (p[2] + p[4]*p[3])*x[4]
    dx[5] = p[4]*p[3]*x[4] - p[2]*x[5]
    dx[6] = p[5] * (p[8] - x[6]) - p[11]*x[6] + p[6]*x[4]*(p[8] - x[6])
    dx[7] = p[5] * (p[9] - x[7]) - p[11]*x[7] + p[7]*x[6]*(p[9] - x[7]) - p[10]*x[4]*x[7]

end

function ODEIndReb(dx, x, p, t) # Induced Rebinding
    # rho1 = p[4],  lambdaR = p[5], rho2 = p[6]
    dx[1] = - p[1]*x[1]*x[2] + p[2]*x[3] + p[5]*x[6] + p[5]*x[7]
    dx[2] = - p[1]*x[1]*x[2] + p[2]*x[3] + p[5]*x[6] + p[5]*x[7]
    dx[3] = p[1] * x[1] * x[2] - (p[2] + p[3])*x[3]
    dx[4] = p[3]*x[3] - (p[2] + p[3])*x[4] + p[4]*x[6]
    dx[5] = p[3]*x[4] - (p[2])*x[5] + p[6]*x[7]
    dx[6] = p[2]*x[4] - (p[4] + p[5] + p[3])*x[6]
    dx[7] = p[3]*x[6] + p[2]*x[5] - (p[6] + p[5])*x[7] 
    dx[8] = (p[3]*x[6] + p[2]*x[5] - (p[6] + p[5])*x[7]) + (p[3]*x[4] - (p[2])*x[5] + p[6]*x[7])

end

function ODEST(dx, x, p, t) # Induced Rebinding
    # S(t) = x1, T(t) = x2, A(t) = x3, Y(t) = x4, lambda = p[1], phi = p[2], s = p[3], k = p[4], ki = p[5], L = p[6], h = p[7]
    dx[1] = -p[1] * p[2] * (x[1]-x[2]) + p[3]*(1-x[1])
    dx[2] =  p[2] * (x[1] - x[2]) + p[3]*(1-x[2]) - p[4] * (x[2]^p[7])*(p[6]^p[7])
    dx[3] =  p[4] * (x[2]^p[7])*(p[6]^p[7]) - p[p[7]]*x[3]
    dx[4] = x[1]/(p[1]+1) + ((x[2]+x[3])*p[1]/(p[1]+1))

end